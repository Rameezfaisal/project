​Cell 6: Business Logic, Transformations & Final Write
​Business Context:
This cell is the "Calculation Engine". It:
​Standardizes Prices: Converts Asian currencies (JPY, TWD, KRW) which are often stored without decimals in SAP.
​Calculates Metrics: Computes OpenQty, PGIQty, and GrossSOPriceUSD using the intricate logic from the SAP script.
​Applies Business Flags: Derived columns like HighDollarFlag and ShipmentDueFlag.
​Final Write: Saves the clean, enriched dataset to your target Delta table.








# Cell 6: Business Logic and Final Write

# --- 1. Define Helper Expressions for Complex Logic ---

# Currency Helper: SAP stores JPY/TWD/KRW without decimals, so we multiply by 100 for reporting
is_asian_curr = F.col("p.vbak_waerk").isin("JPY", "TWD", "KRW")

# Exchange Rate Helper: Use 1.0 if Exchange Rate (KURSK) is missing or Currency is already USD
kursk_calc = F.when((F.col("kursk").isNull()) | (F.col("kursk") == 0) | (F.col("p.vbak_waerk") == 'USD'), F.lit(1.0)) \
              .otherwise(F.col("kursk"))

# --- 2. Apply Intermediate Calculations (Pre-calculation for dependencies) ---
# We calculate these first because other columns (like HighDollarFlag) depend on them.

df_calc = df.withColumn("calc_gross_so_price_usd", 
    F.col("p.vbak_netwr") * F.when(is_asian_curr, kursk_calc * 100).otherwise(kursk_calc)
).withColumn("calc_pgi_qty",
    F.when(F.coalesce(F.col("p.delvd_qty"),F.lit(0)) >= F.coalesce(F.col("p.expectedqtycumulative"),F.lit(0)), 
           F.coalesce(F.col("p.vbep_bmeng"),F.lit(0)))
    .when(F.coalesce(F.col("p.delvd_qty"),F.lit(0)) < F.coalesce(F.col("p.expectedqtycumulative"),F.lit(0)), 
           F.greatest(F.coalesce(F.col("p.vbep_bmeng"),F.lit(0)) - (F.coalesce(F.col("p.expectedqtycumulative"),F.lit(0)) - F.coalesce(F.col("p.delvd_qty"),F.lit(0))), F.lit(0)))
    .otherwise(0)
)

# --- 3. Final Selection & Renaming ---
final_df = df_calc.select(
    # --- Identifiers ---
    F.col("p.vbeln").alias("order"),
    F.expr("ltrim('0', p.vbeln)").alias("orderwz"),
    F.col("p.posnr").alias("line"),
    F.expr("ltrim('0', p.posnr)").alias("linewz"),
    F.col("p.etenr").alias("scheduleline"),
    F.col("p.order_status").alias("orderstatus"),
    
    # --- Grouping Logic ---
    F.when(F.col("p.vbak_auart").isin("ZAS","ZAV","ZFD","ZO11","ZSA","ZSB","ZSR","RK","ZCR1","ZDR1"), "OTH")
     .when(F.col("p.vbak_auart").isin("AG","ZQ01","ZQ03","ZQ04","ZQFO","ZQIS","ZQUP","ZQUX","ZUQT"), "QT")
     .when(F.col("p.vbak_auart").isin("ZO03","ZRA1","ZSO1"), "RPO")
     .when(F.col("p.vbak_auart").isin("ZR11","ZR03","ZR04","ZR05","ZR08","ZR4B","ZUPC","ZUPR","ZFOC"), "RTN")
     .when(F.col("p.vbak_auart").isin("ZO09","ZO12","ZSD","TA","ZCON","ZFO","ZSO","ZUP","ZUPX","ZO04"), "SO")
     .otherwise("SO").alias("ordergroup"),
     
    F.col("p.vbak_auart").alias("ordertype"),

    # --- Dates ---
    F.col("p.vbak_erdat").alias("creationdate"),
    F.col("p.vbap_erdat").alias("lineitemcreationdate"),
    F.col("p.vbep_h_edatu").alias("requestdate"),
    F.col("p.vbep_edatu").alias("deliveryduedate"),
    F.col("p.vbep_mbdat").alias("firmcommitdate"),
    F.col("pgidate").alias("pgidate"),

    # --- Blocks & Status ---
    F.col("p.vbak_lifsk").alias("headerdlvblk"),
    F.col("p.vbep_lifsp").alias("itemdlvblk"),
    F.when(F.coalesce(F.col("p.vbak_faksk"), F.lit('')) != '', F.concat(F.lit("BLK(H) "), F.col("p.vbak_faksk")))
     .when(F.coalesce(F.col("p.vbap_faksp"), F.lit('')) != '', F.concat(F.lit("BLK(L) "), F.col("p.vbap_faksp")))
     .otherwise("").alias("billingblk"),
    
    F.when(F.col("p.vbap_abgru") != '', "True").otherwise("False").alias("solinerejectionflag"),

    # --- Quantities ---
    F.col("p.vbap_kwmeng").alias("orderlineqty"),
    F.col("p.vbep_bmeng").alias("committedqty"),
    F.col("calc_pgi_qty").alias("pgiqty"),
    
    # Open Qty (Simplified for readability, implementing SAP logic)
    F.when(
        (F.coalesce(F.col("p.vbuk_wbstk"), F.lit('')) != 'C') &
        (F.col("p.vbap_abgru") == '') &
        (F.col("p.vbep_bmeng") > 0),
        # If expected - delvd <= committed, use difference, else committed
        F.greatest(
             F.least(
                 F.coalesce(F.col("p.expectedqtycumulative"),F.lit(0)) - F.coalesce(F.col("p.delvd_qty"),F.lit(0)),
                 F.coalesce(F.col("p.vbep_bmeng"),F.lit(0))
             ), 
             F.lit(0)
        )
    ).otherwise(0).alias("openqty"),

    # Inventory
    (F.coalesce(F.col("p.mard_labst"),F.lit(0)) + F.coalesce(F.col("p.mard_kinsm"),F.lit(0))).alias("onhandqty"),
    
    # --- Partners ---
    F.col("soldtoname").alias("soldtoname"),
    F.col("p.shipto").alias("shipto"),
    F.col("p.vbap_werks").alias("vendorplant"),
    
    # --- Material ---
    F.col("p.vbap_matnr").alias("part"),
    F.col("p.vbap_arktx").alias("partdescription"),
    F.col("part_consumable").alias("consumableflag"),
    F.col("matkl").alias("matgrp"),
    
    # --- Financials ---
    F.col("p.vbak_waerk").alias("doccurrency"),
    F.col("calc_gross_so_price_usd").alias("grosssopriceusd"),
    F.when(F.col("calc_gross_so_price_usd") > 50000, "True").otherwise("False").alias("highdollarflag"),
    
    # Unit Price USD
    ((F.when(is_asian_curr, F.col("p.vbap_netpr") * 100).otherwise(F.col("p.vbap_netpr"))) * kursk_calc).alias("unitpriceusd"),

    # Costs (Coalesce 2000 and 3120)
    F.coalesce(F.col("stprs_2000"), F.col("stprs_3120"), F.lit(0)).alias("stdcost"),

    # --- Lookups ---
    F.col("vekp_track").alias("track"),
    F.col("srvcnotif").alias("srvcnotif"),
    F.col("activitytype").alias("activitytype"),
    F.col("laboffice").alias("laboffice"),
    
    # --- Logic Flags ---
    F.when((F.current_date() >= F.col("p.vbep_edatu")) & (F.col("p.poreceived") == 'X'), "True").otherwise("False").alias("shipmentdueflag"),
    F.when(F.current_date() >= F.col("p.vbep_edatu"), "True").otherwise("False").alias("deliverydueflag")
)

# --- 4. Final Write to Delta ---
# Overwrite mode replaces the table content with the new calculation.
# mergeSchema=true ensures if we added new columns, the table updates automatically.

print("Starting Write Operation...")
final_df.write \
    .format("delta") \
    .mode("overwrite") \
    .option("mergeSchema", "true") \
    .saveAsTable(paths["target"])

print(f"SUCCESS: Data successfully written to {paths['target']}")
