# -------------------------------------------------------------------------
# DEBUGGING STEP 4: Isolate where records are lost
# -------------------------------------------------------------------------

# 1. Check Raw Candidates (Before Join)
# This checks if any data even passes your status/reason filters.
candidates_df = (
    df_iplm
    .filter(F.col("part_name") != "NA")
    .filter(F.upper("state") != "CLOSED")
    .filter(
        (F.upper("state").isin("CONFIRMED","IN REVIEW","IN WORK")) |
        (F.upper("disposition").isin("CONFIRMED","DEFER"))
    )
    .filter(F.upper("reason") == "OBSOLETE COMPONENT")
)

candidate_count = candidates_df.count()
print(f"1. Rows passing initial filters (Candidates): {candidate_count}")

# 2. Check Matches in Target
# If Candidates > 0, let's see how many of them exist in OMAT.
if candidate_count > 0:
    matches_df = (
        candidates_df.alias("src")
        .join(
            df_omat_src.alias("tgt"),
            (F.col("src.name") == F.col("tgt.obprno")) &
            (F.col("src.part_name") == F.col("tgt.obprtno")),
            "inner"
        )
    )
    match_count = matches_df.count()
    print(f"2. Candidates already found in OMAT (Matches): {match_count}")
    
    # 3. Final Calculation
    print(f"3. Expected 'New' Rows (Candidates - Matches): {candidate_count - match_count}")
    
    if (candidate_count - match_count) == 0:
        print(">> CONCLUSION: All candidates are already in the target table. There is no new data to process.")
    else:
        print(">> CONCLUSION: There is a join/filter issue in the main Step 4 logic.")
        
else:
    print(">> CONCLUSION: No rows passed the initial filters. Check your 'State' or 'Reason' values in the source table.")
    
    # Optional: Inspect unique values to see if they differ (e.g., 'Obsolute' vs 'OBSOLETE COMPONENT')
    print("--- Diagnostic: Unique Reasons in Source ---")
    df_iplm.select(F.upper("reason")).distinct().show(truncate=False)
    print("--- Diagnostic: Unique States in Source ---")
    df_iplm.select(F.upper("state")).distinct().show(truncate=False)
