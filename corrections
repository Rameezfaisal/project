​Technical Note:
​df_vbfa (from Cell 2) contains flow starting with the Sales Order. This serves as "Table A".
​We need a new read of VBFA for "Table B" because the preceding document for Table B is a Delivery, not a Sales Order, so it wasn't captured in our initial Cell 2 filter.
​We use left joins or standard inner joins as per SAP logic.





Cell 7: Status (JEST) & Inventory (MARD) Logic
​Business Context:
This cell handles two critical lookups:
​Status Flags (JEST): Checks the system status for specific "blocks" or "progress markers" (like 'Front Load', 'PO Received'). We filter this by the OBJNR (Object Number) from the Sales Orders in our scope.
​Inventory Snapshot (MARD): Fetches current stock levels (LABST) for the material at the specific plant/storage location.
​Optimization: We implement a "Calculated Join Key" for the Storage Location (LGORT) to handle the complex business rule (swapping '0010' to '0030' for Plant '3000') efficiently without slowing down the join.





# --- 1. JEST STATUS LOGIC ---
# Filter JEST to only relevant Object Numbers from our Sales Order Header (VBAK)
# This prevents scanning the entire billion-row JEST table
target_objnrs = df_vbak.select("objnr").distinct()

ds_jest = df_jest.alias("j").join(
    target_objnrs, "objnr" # Inner join acts as a filter
).join(
    df_tj30t.alias("t"), 
    F.col("j.stat") == F.col("t.estat"), 
    "left"
).filter(
    (F.col("j.stat").isin('E0001', 'E0004', 'E0005', 'E0008', 'E0009')) & 
    (F.col("j.inact") != "X") & 
    (F.col("t.stsma") == CONST_STATUS_PRF) & # Z0000003
    (F.col("t.spras") == CONST_LANG_KEY)     # E
).groupBy("j.objnr").agg(
    F.max(F.when(F.col("j.stat") == "E0008", "X").otherwise("")).alias("frontload_cd"),
    F.max(F.when(F.col("j.stat") == "E0009", "X").otherwise("")).alias("poreceived_cd"),
    # Booking: If status is E0001/4/5, capture the text description
    F.max(F.when(F.col("j.stat").isin('E0001', 'E0004', 'E0005'), F.col("t.txt04")).otherwise("")).alias("booking_cd")
)

# --- 2. MARD (INVENTORY) LOGIC ---
# Pre-calculate the "Effective Storage Location" on the VBAP side to enable a fast Equi-Join
# Rule: If LGORT is empty or '0010' AND Plant is '3000', use '0030'. Else use LGORT (defaulting '0010' if empty).
df_vbap_calc = df_vbap.withColumn(
    "calc_lgort",
    F.when(
        ((F.coalesce(F.col("lgort"), F.lit("")) == "") | (F.col("lgort") == "0010")) & 
        (F.col("werks") == "3000"), 
        "0030"
    ).when(
        F.coalesce(F.col("lgort"), F.lit("")) != "", 
        F.col("lgort")
    ).otherwise("0010")
)

# We define this lookup to be joined in the final step
# We select only needed columns to keep the plan light
ds_mard = df_mard.select(
    F.col("matnr"), 
    F.col("werks"), 
    F.col("lgort"), 
    F.col("labst").alias("mard_labst"),
    F.col("klabs").alias("mard_klabs"),
    F.col("kinsm").alias("mard_kinsm")
)
