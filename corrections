# Active PRs in iPLM that are Obsolete Components and NOT CLOSED
active_pr_parts_df = (
    iplm_df_raw
    .filter(F.upper(F.col("reason")) == obsolete_reason)
    .withColumn("state_cd", F.upper(F.col("state")))
    .withColumn("disposition_cd", F.upper(F.col("disposition")))
    .filter(
        (F.col("state_cd") != closed_state) &
        (
            F.col("state_cd").isin(active_states) |
            F.col("disposition_cd").isin(active_dispositions)
        )
    )
    .select(
        F.col("name").alias("obprno_key"),
        F.col("part_name").alias("obprtno_key")
    )
    .dropDuplicates()
)

# OMAT existing PR-Part combinations
omat_pairs_df = (
    omat_view_df_raw
    .select(
        F.col("obprno").alias("omat_obprno"),
        F.col("obprtno").alias("omat_obprtno")
    )
    .dropDuplicates()
)

# Find same part in other PRs
duplicate_pairs_df = (
    active_pr_parts_df.alias("a")
    .join(
        omat_pairs_df.alias("b"),
        (F.col("a.obprtno_key") == F.col("b.omat_obprtno")) &
        (F.col("a.obprno_key") != F.col("b.omat_obprno")),
        "inner"
    )
    .select(
        F.col("a.obprtno_key").alias("part_name_dup"),
        F.col("a.obprno_key").alias("related_pr")
    )
)

rltdprs_df = (
    duplicate_pairs_df
    .groupBy("part_name_dup")
    .agg(
        F.concat_ws(",", F.collect_list("related_pr")).alias("openprs"),
        F.lit("Yes").alias("duplicate_pr_flag")
    )
)

rltdprs_df.createOrReplaceTempView("vw_rltdprs")












enrichment_src_df = (
    iplm_df_raw
    .filter(F.upper(F.col("reason")) == obsolete_reason)
    .withColumn("state_cd", F.upper(F.col("state")))
    .withColumn("disposition_cd", F.upper(F.col("disposition")))
    .filter(
        (F.col("state_cd").isin(active_states)) |
        (F.col("disposition_cd").isin(active_dispositions))
    )
    .select(
        F.col("name").alias("obprno_upd"),
        F.col("part_name").alias("obprtno_upd"),
        F.col("mstae").alias("part_status_new"),
        F.col("state_cd").alias("obpr_state_new"),
        F.col("is_the_last_time_buy_available").alias("is_ltb_avail_new"),
        F.col("ob_last_buy_date").alias("ltb_date_new"),
        F.col("lrc_suppliers_date_to_zero_inventory").alias("supplier_date_to_zero_new"),
        "submitted_date"
    )
    .join(
        rltdprs_df.alias("r"),
        F.col("obprtno_upd") == F.col("r.part_name_dup"),
        "left"
    )
    .select(
        "obprno_upd",
        "obprtno_upd",
        "part_status_new",
        "obpr_state_new",
        "is_ltb_avail_new",
        "ltb_date_new",
        "supplier_date_to_zero_new",
        F.col("openprs").alias("reltd_ob_pr_new"),
        F.col("duplicate_pr_flag").alias("duplicate_pr_flag_new")
    )
    .dropDuplicates(["obprno_upd", "obprtno_upd"])
)

(
    obprtno_delta.alias("t")
    .merge(
        enrichment_src_df.alias("s"),
        "t.obprno = s.obprno_upd AND t.obprtno = s.obprtno_upd"
    )
    .whenMatchedUpdate(set={
        "part_status": "s.part_status_new",
        "obpr_state": "s.obpr_state_new",
        "is_ltb_avail": "s.is_ltb_avail_new",
        "ltb_date": "s.ltb_date_new",
        "supplier_date_to_zero": "s.supplier_date_to_zero_new",
        "reltd_ob_pr": "s.reltd_ob_pr_new",
        "duplicate_pr_flag": "s.duplicate_pr_flag_new",
        "last_modified_on": "current_timestamp()"
    })
    .execute()
)












duplicate_parts_df = (
    spark.table(tgt_obprtno_dtls_tbl)
    .filter(F.col("reltd_ob_pr").isNotNull() & (F.length(F.col("reltd_ob_pr")) > 0))
    .filter(F.col("obprtno") != "NA")
    .select(F.col("obprtno").alias("dup_part_key"))
    .dropDuplicates()
)

active_iplm_for_dup_df = (
    iplm_df_raw
    .filter(F.upper(F.col("reason")) == obsolete_reason)
    .withColumn("state_cd", F.upper(F.col("state")))
    .withColumn("disposition_cd", F.upper(F.col("disposition")))
    .filter(
        (F.col("state_cd") != closed_state) &
        (
            F.col("state_cd").isin(active_states) |
            F.col("disposition_cd").isin(active_dispositions)
        )
    )
    .select(
        F.col("part_name").alias("dup_part_key"),
        "submitted_date"
    )
)

duplicatepr_df = (
    duplicate_parts_df.alias("d")
    .join(active_iplm_for_dup_df.alias("i"), "dup_part_key")
    .groupBy("dup_part_key")
    .agg(F.max("submitted_date").alias("latest_submitted_date"))
)

duplicatepr_df.createOrReplaceTempView("vw_duplicatepr")











ltbinfo_df = (
    iplm_df_raw
    .filter(F.upper(F.col("reason")) == obsolete_reason)
    .withColumn("state_cd", F.upper(F.col("state")))
    .withColumn("disposition_cd", F.upper(F.col("disposition")))
    .filter(
        (F.col("part_name") != "NA") &
        (F.col("state_cd") != closed_state) &
        (
            F.col("state_cd").isin(active_states) |
            F.col("disposition_cd").isin(active_dispositions)
        )
    )
    .select(
        F.col("part_name").alias("ltb_part_key"),
        "submitted_date",
        F.col("is_the_last_time_buy_available").alias("is_ltb_avail_new"),
        F.col("ob_last_buy_date").alias("ltb_date_new"),
        F.col("lrc_suppliers_date_to_zero_inventory").alias("supplier_date_to_zero_new")
    )
    .join(
        duplicatepr_df.alias("d"),
        (F.col("ltb_part_key") == F.col("d.dup_part_key")) &
        (F.col("submitted_date") == F.col("latest_submitted_date")),
        "inner"
    )
    .select(
        "ltb_part_key",
        "is_ltb_avail_new",
        "ltb_date_new",
        "supplier_date_to_zero_new"
    )
    .dropDuplicates(["ltb_part_key"])
)

ltbinfo_df.createOrReplaceTempView("vw_ltbinfo")