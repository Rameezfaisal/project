# Cell 3: Main Source Reading and Optimization Logic (Fixed for NULL Dates)

# 1. Parse Input Parameters
input_sales_org = [x.strip() for x in params["IP_SALES_ORG"].split(",")]
input_order_type = [x.strip() for x in params["IP_ORDER_TYPE"].split(",")]

# 2. Read the Main Driving Table
prst_df = spark.read.table(paths["prst"])

# 3. Define Base Filter
#    Exclude specific technical types.
#    Note: We removed the hard date check here to handle it more gracefully below.
base_filter = (~F.col("vbak_auart").isin("ZVC", "ZR07"))

# 4. Define Dynamic Date Logic with NULL Handling
date_flag = params["IP_DATE_FLAG"]
from_date = params["IP_ERDAT_FROM"]
to_date = params["IP_ERDAT_TO"]

# Helper: Define which column to check based on the flag
if date_flag == 'L':    # Line Creation Date
    # FIX: If vbap_erdat is NULL, fallback to vbak_erdat (Header Date)
    target_col = F.coalesce(F.col("vbap_erdat"), F.col("vbak_erdat"))
elif date_flag == 'P':  # PGI Date
    target_col = F.col("pgidate")
elif date_flag == 'R':  # Schedule Line Date
    target_col = F.col("vbep_h_edatu")
elif date_flag == 'C':  # Header Creation Date
    target_col = F.col("vbak_erdat")
elif date_flag == 'F':  # Material Availability Date
    target_col = F.col("vbep_mbdat")
elif date_flag == 'A':  # Line Change Date
    target_col = F.col("vbap_aedat")
else:
    target_col = None

# Construct the Date Condition
# Logic: (Date is within Range) OR (Order is Open) OR (Date Flag is 'N')
# This guarantees 'Open' orders survive even if their dates are NULL.
if date_flag == 'N' or target_col is None:
    date_cond = F.lit(True)
else:
    date_cond = (
        (target_col.between(from_date, to_date)) | 
        (F.col("order_status") == "Open")
    )

# 5. Define Organization & Type Filters
if 'ALL' in input_sales_org:
    org_cond = F.lit(True)
else:
    org_cond = F.col("vbak_vkorg").isin(input_sales_org)

if 'ALL' in input_order_type:
    type_cond = F.lit(True)
else:
    type_cond = F.col("vbak_auart").isin(input_order_type)

# 6. Apply All Filters
prst_filtered = prst_df.filter(base_filter & date_cond & org_cond & type_cond)

# 7. Cache the result
prst_filtered.cache()

# Verification
print(f"Base Table Loaded. Filtered Row Count: {prst_filtered.count()}")
