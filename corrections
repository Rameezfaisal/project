# ==============================================================================
# CORRECTED Step-6: LTB OPEN PO DATASET (Fixing Status Logic)
# ==============================================================================

# ... [Keep your existing Read logic for zpo_hist_active_df & zpo_hist_arch_df] ...

# Combine active + archive
zpo_hist_all_df = zpo_hist_active_df.unionByName(zpo_hist_arch_df)

# CORRECTED FILTER LOGIC:
# SAP: WHERE ... B.CLOSED = 'CLSCOMP' ... OR ... D.STATUS <> 'INACT'
# Spark Previous: (col("status_flag").isNull()) -> WRONG (Drops 'ACTIVE' rows)
# Spark Corrected: Keep if Closed is valid OR Status is NOT 'INACT'
ltb_hist_df = zpo_hist_all_df.filter(
    (F.col("closed_flag").isin("CLSCOMP", "CLSZERO")) | 
    ((F.col("status_flag") != "INACT") | (F.col("status_flag").isNull()))
)

# ... [The rest of Step 6 (part_supp_df creation) remains exactly the same] ...
# Just re-run the part_supp_df creation block after this filter fix.












# ==============================================================================
# CORRECTED Step-10: LTB OPEN PO SUPPLIERS (Strict Inner Join)
# ==============================================================================
ltb_supplier_df = temp_table_df.alias("t") \
    .join(
        ob_base_df.alias("o"),
        F.col("t.material_tt") == F.col("o.obprtno"),
        "inner"
    ) \
    .join(
        dmd_df.alias("d"),
        F.col("d.cmpprtno_dmd") == F.col("o.obprtno"),
        "inner"  # <--- FIXED: Changed from LEFT to INNER to match SAP behavior
    ) \
    .select(
        F.col("o.obprno"),
        F.col("o.obprtno"),
        F.coalesce(F.col("d.nha_dmd"), F.col("o.obprtno")).alias("nha"),
        F.col("t.vencode_tt").alias("vencode"),
        F.col("t.venname_tt").alias("venname"),
        F.lit("NA").alias("is_ltb_avail"),
        F.lit(None).cast("date").alias("ltbdate"),
        F.lit(0).alias("ltbqty"),
        F.lit(0).alias("qty_liable_supplier"),
        F.lit(None).cast("int").alias("qty_available_supplier"),
        F.lit(None).cast("date").alias("lrc_suppliers_date_to_zero_inventory"),
        F.col("d.lamqoh_dmd").cast("int").alias("lamqoh"),
        F.col("d.open_po_qty_dmd").cast("int").alias("open_po_qty"),
        F.lit(refresh_frequency_days).alias("refresh_frequency"),
        F.lit(None).cast("date").alias("supply_last_updated"),
        F.current_date().alias("last_request_date"),
        F.date_add(F.current_date(), refresh_frequency_days).alias("next_request_date"),
        F.lit("N").alias("obsupplier"),
        F.col("d.restricted_all_stock_dmd").cast("int").alias("restricted_all_stock")
    ) \
    .distinct()

ltb_supplier_df.cache()
print(f"Corrected Step 10 Count: {ltb_supplier_df.count()}")










# ==============================================================================
# CORRECTED Step-15: Final UNION (Including WW Supplier)
# ==============================================================================

final_supplier_inventory_df = (
    ob_supplier_df
    .unionByName(nha_supplier_df)
    .unionByName(ltb_supplier_df)
    .unionByName(rscxd_supplier_df)
    .unionByName(all_suppliers_part_df)
    .unionByName(all_suppliers_nha_df)
    .unionByName(all_suppliers_component_df)
    .unionByName(ww_supplier_df)  # <--- ADDED: Missing World Wide Supplier Block
).distinct()

final_supplier_inventory_df.cache()
print(f"Final Total Row Count: {final_supplier_inventory_df.count()}")
