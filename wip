# ------- CELL 4: Pre-Calculations (The "CTEs") --------
# Purpose: Replicate the derived tables (subqueries) from the SQL FROM clause
# to isolate aggregations and complex window functions.

# 1. Subquery 't': Cumulative Committed Qty (Replaces VBEP Self-Join)
# SQL: SUM(t2.BMENG) ... WHERE t1.ETENR >= t2.ETENR
w_cum = Window.partitionBy("VBELN", "POSNR").orderBy("ETENR").rowsBetween(Window.unboundedPreceding, Window.currentRow)

df_t = df_vbep.filter(F.col("BMENG") > 0) \
    .select("VBELN", "POSNR", "ETENR", "BMENG") \
    .withColumn("ExpectedQtyCumulative", F.sum("BMENG").over(w_cum)) \
    .alias("t")

# 2. Subquery 'h': Schedule Line 0001 only (Request Date)
df_h = df_vbep.filter(F.col("ETENR") == "0001") \
    .select(F.col("VBELN").alias("h_VBELN"), 
            F.col("POSNR").alias("h_POSNR"), 
            F.col("EDATU").alias("RequestDate")) \
    .alias("h")

# 3. Subquery 'f1': Delivered Qty (VBFA Aggregation)
# Logic: Sum RFMNG based on VBTYP_N (R=+, h=-)
df_f1 = df_vbfa.filter((F.col("STUFE") == "00") & (F.col("VBTYP_N").isin("T", "J"))) \
    .groupBy(F.col("VBELV").alias("f1_VBELV"), F.col("POSNV").alias("f1_POSNV")) \
    .agg(
        F.sum(
            F.when((F.col("VBTYP_N") == "R") & (F.col("PLMIN") == "+"), F.coalesce(F.col("RFMNG_FLO"), F.lit(0)))
            .when(F.col("VBTYP_N") == "h", F.coalesce(F.col("RFMNG_FLO"), F.lit(0)) * -1)
            .otherwise(0)
        ).alias("delvd_qty")
    ).alias("f1")

# 4. Subquery 'f2': PGI Qty and Last PGI Doc (VBFA Aggregation)
df_f2 = df_vbfa.filter(
        (F.col("STUFE") == "00") & 
        (F.col("VBTYP_N").isin("T", "J")) & 
        (F.col("VBELN").like("49%"))
    ).groupBy(F.col("VBELV").alias("f2_VBELV"), F.col("POSNV").alias("f2_POSNV")) \
    .agg(
        F.max("VBELN").alias("LastPGIDoc"),
        F.sum(
            F.when(F.col("VBTYP_N") == "R", F.coalesce(F.col("RFMNG"), F.lit(0)))
            .when(F.col("VBTYP_N") == "h", F.coalesce(F.col("RFMNG"), F.lit(0)) * -1)
            .otherwise(0)
        ).alias("PGIQty")
    ).alias("f2")

# 5. Subquery 'l': Delivery Status (LIPS/LIKP Join)
# Logic: Aggregates on Preceding Doc (VGBEL/VGPOS)
df_l = df_lips.filter((F.col("VGBEL") != "") & 
                      (~F.col("VGBEL").like("4%")) & 
                      (~F.col("VGBEL").like("3%"))) \
    .join(df_likp, df_lips.VBELN == df_likp.VBELN) \
    .filter(df_likp.WADAT_IST != "") \
    .groupBy(df_lips.VGBEL, df_lips.VGPOS) \
    .agg(
        F.max(df_lips.VBELN).alias("OpenDlvDoc"),
        F.sum(df_lips.LGMNG).alias("OpenDlvQty"),
        F.sum(F.when(df_likp.WADAT_IST == "", 0).otherwise(df_lips.LFIMG)).alias("QtyShippedTtLine"),
        F.max(df_likp.WADAT_IST).alias("PGIDate")
    ) \
    .withColumn("DlvStatus", F.when(F.col("PGIDate") == "", "Created").otherwise("Shipped")) \
    .select(F.col("VGBEL").alias("l_VGBEL"), 
            F.col("VGPOS").alias("l_VGPOS"), 
            "OpenDlvDoc", "OpenDlvQty", "QtyShippedTtLine", "PGIDate", "DlvStatus") \
    .alias("l")

# 6. Subquery 'x': Exchange Rates
# Logic: Get Min GDATU for USD to find the active rate
df_tcurr_usd = df_tcurr.filter(F.col("TCURR") == "USD")
df_bc = df_tcurr_usd.groupBy("FCURR", "TCURR").agg(F.min("GDATU").alias("min_gdatu"))

df_x = df_tcurr.alias("ab").join(df_bc.alias("bc"), 
    (F.col("ab.FCURR") == F.col("bc.FCURR")) & 
    (F.col("ab.TCURR") == F.col("bc.TCURR")) & 
    (F.col("ab.GDATU") == F.col("bc.min_gdatu"))
).select(
    F.col("ab.FCURR").alias("x_FCURR"), 
    F.abs(F.col("ab.UKURS")).alias("UKURS2")
).alias("x")

# 7. Subquery 'c': ShipTo Party
df_c = df_vbpa.alias("v").filter((F.col("POSNR") == "000000") & (F.col("PARVW") == "WE")) \
    .join(df_kna1.alias("k"), F.col("v.KUNNR") == F.col("k.KUNNR")) \
    .select(F.col("v.VBELN").alias("c_VBELN"), 
            F.col("v.KUNNR").alias("ShipTo"), 
            F.col("k.NAME1").alias("ShipToName")) \
    .alias("c")

# 8. Subquery 'j': JEST/TJ30T Statuses
# Logic: Pivot specific E-statuses to columns
df_j = df_jest.filter(
        F.col("STAT").isin("E0001", "E0004", "E0005", "E0008", "E0009") & 
        (F.col("INACT") != "X")
    ).join(df_tj30t, (df_jest.STAT == df_tj30t.ESTAT) & (df_tj30t.STSMA == "Z0000003") & (df_tj30t.SPRAS == "E"), "left") \
    .groupBy("OBJNR") \
    .agg(
        F.max(F.when(F.col("STAT") == "E0008", "X").otherwise("")).alias("FrontLoad"),
        F.max(F.when(F.col("STAT") == "E0009", "X").otherwise("")).alias("POReceived"),
        F.max(F.when(F.col("STAT").isin("E0001", "E0004", "E0005"), F.col("TXT04")).otherwise("")).alias("Booking")
    ).alias("j")












# ------- CELL 5: The Main Join (Logic & Deduplication) --------

# We need to calculate the join key for MARD (Subquery 'r') on the VBAP side first
# Logic: IF LGORT in ('', '0010') AND WERKS='3000' THEN '0030' ...
df_p_prep = df_vbap.withColumn("Calc_LGORT", 
    F.when((F.coalesce(F.col("LGORT"), F.lit("")) .isin("", "0010")) & (F.col("WERKS") == "3000"), "0030")
     .when(F.coalesce(F.col("LGORT"), F.lit("")) != "", F.col("LGORT"))
     .otherwise("0010")
)

# Start with VBUK (Base)
# Join Sequence: VBUK -> VBAK -> KNA1 -> VBAP -> PART -> VBEP
df_main = df_vbuk.join(df_vbak, df_vbuk.VBELN == df_vbak.VBELN) \
    .join(df_kna1, df_vbak.KUNNR == df_kna1.KUNNR) \
    .join(df_p_prep, df_vbak.VBELN == df_p_prep.VBELN) \
    .join(df_part, df_p_prep.MATNR == df_part.Part) \
    .join(df_vbep, (df_p_prep.VBELN == df_vbep.VBELN) & (df_p_prep.POSNR == df_vbep.POSNR))

# --- DEDUPLICATION STRATEGY ---
# Before adding the Left Joins, we resolve column collisions by relying on 
# specific aliasing in the final select or creating a clean DataFrame here if needed.
# For now, we will use the Alias DataFrames defined in Cell 3 in the join conditions
# but we must reference them carefully.

# To ensure the logic 'df_p_prep' works with aliases 'p', we re-alias the main chain temporarily for the next joins
# But simpler: We will perform the joins using the columns from df_main against the Lookup DataFrames.

df_joined = df_main \
    .join(df_h, (F.col("p.VBELN") == F.col("h_VBELN")) & (F.col("p.POSNR") == F.col("h_POSNR"))) \
    .join(df_t, (F.col("e.VBELN") == F.col("t.VBELN")) & (F.col("e.POSNR") == F.col("t.POSNR")) & (F.col("e.ETENR") == F.col("t.ETENR"))) \
    .join(df_vbup, (F.col("p.VBELN") == df_vbup.VBELN) & (F.col("p.POSNR") == df_vbup.POSNR)) \
    .join(df_f1, (df_vbup.VBELN == F.col("f1_VBELV")) & (df_vbup.POSNR == F.col("f1_POSNV")), "left") \
    .join(df_f2, (df_vbup.VBELN == F.col("f2_VBELV")) & (df_vbup.POSNR == F.col("f2_POSNV")), "left") \
    .join(df_c, df_vbak.VBELN == F.col("c_VBELN")) \
    .join(df_mara, df_p_prep.MATNR == df_mara.MATNR) \
    .join(df_t024x, df_mara.LABOR == df_t024x.LABOR, "left") \
    .join(df_mard, 
          (df_p_prep.WERKS == df_mard.WERKS) & 
          (df_p_prep.MATNR == df_mard.MATNR) & 
          (df_p_prep.Calc_LGORT == df_mard.LGORT), 
          "left") \
    .join(df_marc, (df_p_prep.WERKS == df_marc.WERKS) & (df_p_prep.MATNR == df_marc.MATNR), "left") \
    .join(df_l, (df_p_prep.VBELN == F.col("l_VGBEL")) & (df_p_prep.POSNR == F.col("l_VGPOS")), "left") \
    .join(df_mbew, (df_p_prep.MATNR == df_mbew.MATNR) & (df_mbew.BWKEY == "2000"), "left") \
    .join(df_vbkd.alias("hd"), (df_p_prep.VBELN == F.col("hd.VBELN")) & (F.col("hd.POSNR") == "000000"), "left") \
    .join(df_vbkd.alias("d"), (df_p_prep.VBELN == F.col("d.VBELN")) & (df_p_prep.POSNR == F.col("d.POSNR")), "left") \
    .join(df_j, df_vbak.OBJNR == df_j.OBJNR, "left") \
    .join(df_vekp.alias("y"), F.col("f1_VBELV") == F.col("y.VPOBJKEY"), "left") \
    .join(df_x, df_vbak.WAERK == F.col("x_FCURR"), "left") \
    .join(df_qmel, df_vbak.VBELN == df_qmel.AUFNR, "left") \
    .join(df_spares.alias("xy"), (df_p_prep.VBELN == F.col("xy.ORDER_NO")) & (df_p_prep.POSNR == F.col("xy.ORDER_LINE_NO")), "left") \
    .join(df_afko, df_vbak.AUFNR == df_afko.AUFNR, "left")

# Note: The complex join for 'ACT' (Activity Type) involving AFVC aggregation was added at the end of the SQL.
# We add it here as a left join.
df_act = df_afvc.groupBy("AUFPL").agg(F.min("VORNR").alias("min_vornr")) \
    .join(df_afvc.alias("full_afvc"), (F.col("AUFPL") == F.col("full_afvc.AUFPL")) & (F.col("min_vornr") == F.col("full_afvc.VORNR"))) \
    .select(F.col("AUFPL"), F.col("full_afvc.LARNT").alias("ActivityType"))

df_final_join = df_joined.join(df_act, df_afko.AUFPL == df_act.AUFPL, "left")

# APPLY FILTERS (WHERE CLAUSE)
# Logic: WERKS >= 1900 AND AUART NOT IN ('ZVC','ZR07') AND (Date logic OR Status Logic)
df_filtered = df_final_join.filter(
    (F.col("p.WERKS") >= "1900") & 
    (~F.col("a.AUART").isin("ZVC", "ZR07")) & 
    (
        (F.col("p.ERDAT") >= F.date_add(F.current_date(), -732)) |
        (
            (F.coalesce(F.col("u.WBSTK"), F.lit("")) != "C") & 
            (F.coalesce(F.col("u.LFGSK"), F.lit("")) != "C") & 
            (F.coalesce(F.col("p.ABGRU"), F.lit("")) == "") & 
            (F.coalesce(F.col("b.LFSTA"), F.lit("")).isin("", "") == False) & # Logic: NOT IN ('','')
            (F.coalesce(F.col("p.KWMENG"), F.lit(0)) > F.coalesce(F.col("delvd_qty"), F.lit(0))) & 
            (F.coalesce(F.col("e.BMENG"), F.lit(0)) > 0)
            # Note: The complex CASE WHEN logic for BackOrderQty > 0 is handled in the projection or can be added here.
            # For performance, we often filter simpler conditions first.
        )
    )
)









# ------- CELL 6: Final Projection (Business Logic & Output) --------

# Helper Columns for complex calculations
# We calculate 'BackOrderLogic' first to simplify the CASE WHEN
# SQL: CASE WHEN ExpectedQty - Delvd <= BMENG THEN ...
cond_bo_1 = F.coalesce(F.col("ExpectedQtyCumulative"), F.lit(0)) <= F.coalesce(F.col("delvd_qty"), F.lit(0))
cond_bo_2 = (F.coalesce(F.col("ExpectedQtyCumulative"), F.lit(0)) - F.coalesce(F.col("delvd_qty"), F.lit(0))) <= F.coalesce(F.col("e.BMENG"), F.lit(0))

df_result = df_filtered.select(
    # --- Status Flags ---
    F.when(
        (F.coalesce(F.col("u.WBSTK"), F.lit("")) != "C") & 
        (F.coalesce(F.col("p.ABGRU"), F.lit("")) == "") & 
        (F.coalesce(F.col("b.LFSTA"), F.lit("")) != "") &
        (F.coalesce(F.col("p.KWMENG"), F.lit(0)) > F.coalesce(F.col("delvd_qty"), F.lit(0))) &
        (F.coalesce(F.col("e.BMENG"), F.lit(0)) > 0),
        "Open"
    ).otherwise("Closed").alias("OrderStatus"),

    # --- Order Group ---
    F.when(F.col("a.AUART").isin('ZAS','ZAV','ZFD','ZO11','ZSA','ZSB','ZSR','RK','ZCR1','ZDR1'), 'OTH')
     .when(F.col("a.AUART").isin('AG','ZQ01','ZQ03','ZQ04','ZQFO','ZQIS','ZQUP','ZQUX','ZUQT'), 'QT')
     .when(F.col("a.AUART").isin('ZO03','ZRA1','ZSO1'), 'RPO')
     .when(F.col("a.AUART").isin('ZR11','ZR03','ZR04','ZR05','ZR08','ZR4B','ZUPC','ZUPR','ZFOC'), 'RTN')
     .when(F.col("a.AUART").isin('ZO09','ZO12','ZSD','TA','ZCON','ZFO','ZSO','ZUP','ZUPX','ZO04'), 'SO')
     .otherwise('SO').alias("OrderGroup"),

    F.col("a.VBELN").alias("Order"),
    F.expr("LTRIM('0', a.VBELN)").alias("OrderWZ"),
    F.col("p.POSNR").alias("Line"),
    F.expr("LTRIM('0', p.POSNR)").alias("LineWZ"),
    F.col("e.ETENR").alias("ScheduleLine"),
    F.expr("LTRIM('0', e.ETENR)").alias("ScheduleLineWZ"),
    F.col("a.AUART").alias("OrderType"),
    F.col("p.ABGRU").alias("RejectionCodeLine"),
    F.col("a.ERDAT").alias("CreationDate"),
    F.col("p.ERDAT").alias("LineItemCreationDate"),
    F.col("p.ERZET").alias("LineItemCreationTime"),
    F.col("h.RequestDate").alias("RequestDate"),
    F.col("e.EDATU").alias("DeliveryDueDate"),
    F.lit(None).alias("StatRelvDate"),
    F.lit(None).alias("ItemDeliveryDate"),
    F.col("a.LIFSK").alias("HeaderDlvBlk"),
    F.col("e.LIFSP").alias("ItemDlvBlk"),
    
    F.when(F.coalesce(F.col("a.FAKSK"), F.lit("")) != "", F.concat(F.lit("BLK(H) "), F.col("a.FAKSK")))
     .when(F.coalesce(F.col("p.FAKSP"), F.lit("")) != "", F.concat(F.lit("BLK(L) "), F.col("p.FAKSP")))
     .otherwise("").alias("BillingBlk"),

    F.col("p.KWMENG").alias("OrderLineQty"),
    F.col("e.BMENG").alias("CommittedQty"),
    
    # PGI Qty Calculation
    F.when(F.coalesce(F.col("delvd_qty"), F.lit(0)) >= F.coalesce(F.col("ExpectedQtyCumulative"), F.lit(0)), F.coalesce(F.col("e.BMENG"), F.lit(0)))
     .when(F.coalesce(F.col("delvd_qty"), F.lit(0)) < F.coalesce(F.col("ExpectedQtyCumulative"), F.lit(0)), 
           F.greatest(F.coalesce(F.col("e.BMENG"), F.lit(0)) - (F.coalesce(F.col("ExpectedQtyCumulative"), F.lit(0)) - F.coalesce(F.col("delvd_qty"), F.lit(0))), F.lit(0)))
     .otherwise(0).alias("PGIQty"),

    F.lit(None).alias("Intransit"),
    F.lit(None).alias("GRQty"),

    # Open Qty Logic (Complex)
    F.when(
        (F.coalesce(F.col("u.WBSTK"), F.lit("")) != "C") & 
        (F.col("p.ABGRU") == "") & 
        (F.coalesce(F.col("b.LFSTA"), F.lit("")) != "") &
        (F.coalesce(F.col("p.KWMENG"), F.lit(0)) > F.coalesce(F.col("delvd_qty"), F.lit(0))) & 
        (F.coalesce(F.col("e.BMENG"), F.lit(0)) > 0),
        F.when(cond_bo_1, 0)
         .when(cond_bo_2, F.coalesce(F.col("ExpectedQtyCumulative"), F.lit(0)) - F.coalesce(F.col("delvd_qty"), F.lit(0)))
         .otherwise(F.coalesce(F.col("e.BMENG"), F.lit(0)))
    ).otherwise(0).alias("OpenQty"),

    (F.coalesce(F.col("r.LABST"), F.lit(0)) + F.coalesce(F.col("r.KINSM"), F.lit(0))).alias("OnHandQty"),
    F.col("r.KLABS").alias("VendorOwned"),
    
    F.when(F.coalesce(F.col("e.BMENG"), F.lit(0)) < F.coalesce(F.col("r.QOH"), F.lit(0)), F.coalesce(F.col("e.BMENG"), F.lit(0)))
     .otherwise(F.coalesce(F.col("r.QOH"), F.lit(0))).alias("AvailToShip"),

    F.coalesce(F.col("OpenDlvDoc"), F.lit("")).alias("LastDlvDoc"),
    F.col("OpenDlvQty").alias("LastDlvQty"),
    F.col("QtyShippedTtLine"),
    F.lit(None).alias("QtyNetReceivedLine"),
    F.coalesce(F.col("DlvStatus"), F.lit("None")).alias("LastDlvStatus"),
    F.lit(None).alias("PurchaseOrg"),
    F.col("a.VKORG").alias("SalesOrg"),
    F.col("a.KUNNR").alias("SoldTo"),
    F.expr("LTRIM('0', a.KUNNR)").alias("SoldToWZ"),
    F.col("k.NAME1").alias("SoldToName"),
    F.col("ShipTo"),
    F.expr("LTRIM('0', ShipTo)").alias("ShipToWZ"),
    F.col("ShipToName"),
    F.col("p.WERKS").alias("VendorPlant"),
    F.col("Calc_LGORT").alias("VendorSloc"),
    F.col("p.VSTEL").alias("ShippingPoint"),
    F.lit(None).alias("ReceivingPlant"),
    F.lit(None).alias("ReceivingSloc"),
    F.col("p.MATNR").alias("Part"),
    F.col("p.ARKTX").alias("PartDescription"),
    F.col("pp.Consumable").alias("ConsumableFlag"),
    F.col("y.EXIDV2").alias("Track"),
    F.col("e.MBDAT").alias("FirmCommitDate"),
    F.col("a.AUTLF").alias("CompDlv"),
    F.col("m.MATKL").alias("MatGrp"),
    F.col("d.IHREZ").alias("CSRep"),
    F.col("a.BSTNK").alias("CustomerPO"),

    # Price Calculation (USD)
    F.when(F.col("a.WAERK").isin('JPY','TWD','KRW'), F.col("p.NETPR") * 100).otherwise(F.col("p.NETPR")).alias("UnitPriceLocalCurr"),
    
    (F.when(F.col("a.WAERK").isin('JPY','TWD','KRW'), F.col("p.NETPR") * 100).otherwise(F.col("p.NETPR")) * F.col("e.BMENG")).alias("ExtPriceLocalCurr"),
    
    F.col("a.WAERK").alias("DocCurrency"),

    (F.when(F.col("a.WAERK").isin('JPY','TWD'), F.col("p.NETPR") * 100).otherwise(F.col("p.NETPR")) * F.when((F.coalesce(F.col("hd.KURSK"), F.lit(0)) == 0) | (F.col("a.WAERK") == 'USD'), 1).otherwise(F.col("hd.KURSK"))).alias("UnitPriceUSD"),
    
    (F.when(F.col("a.WAERK").isin('JPY','TWD'), F.col("p.NETPR") * 100).otherwise(F.col("p.NETPR")) * F.when((F.coalesce(F.col("hd.KURSK"), F.lit(0)) == 0) | (F.col("a.WAERK") == 'USD'), 1).otherwise(F.col("hd.KURSK")) * F.col("e.BMENG")).alias("ExtPriceUSD"),

    F.col("w.STPRS").alias("StdCost"),
    (F.col("w.STPRS") * F.col("e.BMENG")).alias("ExtCost"),
    F.lit("USD").alias("StdCurrency"),
    
    F.when(F.col("p.LPRIO") == "00", "04").otherwise(F.col("p.LPRIO")).alias("DPrio"),
    F.col("p.CHARG").alias("BatchNo"),
    F.col("LastPGIDoc").alias("PGIDoc"),
    F.col("l.PGIDate").alias("PGIDate"),
    F.col("a.OBJNR").alias("NCUPhase2"),
    F.col("a.VSNMR_V").alias("FCID_SlsDocVersion"),
    F.col("i.LBTXT").alias("LabOffice"),
    F.col("z.DISPO").alias("MRPV"),
    F.lit(None).alias("MRPC"),
    F.col("p.GRKOR").alias("DlvGrp"),
    F.lit(None).alias("DlvCreationDate"),
    F.col("q.QMNUM").alias("SrvcNotif"),
    F.col("FrontLoad"),
    F.col("POReceived"),
    F.col("Booking"),
    F.col("p.PRODH").alias("ProdHier"),
    F.lit(None).alias("STOItemText"),
    F.lit(None).alias("MaterialMemo"),
    F.col("z.EKGRP").alias("PurchaseGrp"),
    F.col("m.MSTAE").alias("XPlantStatus"),
    F.col("p.KDMAT").alias("CustomerMaterial"),
    F.col("p.ERNAM").alias("LineChangedBy"),
    
    F.when(F.col("d.INCO1").isNull(), F.col("hd.INCO1")).otherwise(F.col("d.INCO1")).alias("Incoterms"),
    F.col("a.IHREZ").alias("CsOwner"),
    F.col("a.ERNAM").alias("CreatedBy"),
    F.col("a.AUFNR").alias("AssocServOrd"),
    F.col("p.AEDAT").alias("LinePrevChangeDate"),
    
    F.when(F.col("a.WAERK") == "KRW", (1 / F.col("hd.KURSK")) * 100).otherwise(1 / F.col("hd.KURSK")).alias("ExchangeRate"),
    F.col("hd.PRSDT").cast("string").alias("PricingDate"),

    # Region Logic
    F.when(F.col("a.VKORG") == '9000', 'NA')
     .when(F.col("a.VKORG").between('2000', '2900'), 'EU')
     .when(F.col("a.VKORG").between('3000', '3001'), 'JP')
     .when(F.col("a.VKORG") == '3100', 'TW')
     .when(F.col("a.VKORG") == '3200', 'KR')
     .when((F.col("a.VKORG") == '3300') | (F.col("a.VKORG") == '3600'), 'SEA')
     .when(F.col("a.VKORG").isin('3400', '3410', '1000'), 'CN')
     .otherwise('NEW').alias("Region"),

    F.when(F.col("m.LABOR") == "023", "SPIN")
     .when(F.col("m.LABOR") == "024", "DEP")
     .otherwise("ETCH+").alias("ToolType"),

    F.when((F.current_date() >= F.col("e.EDATU")) & (F.col("POReceived") == "X"), "True").otherwise("False").alias("ShipmentDueFlag"),

    # GrossSOPriceUSD
    (F.col("a.NETWR") * F.when(F.col("a.WAERK").isin('JPY', 'TWD'), 
            F.when(F.coalesce(F.col("hd.KURSK"), F.lit(0)) == 0, 1).otherwise(F.col("hd.KURSK")) * 100
           ).otherwise(
            F.when(F.coalesce(F.col("hd.KURSK"), F.lit(0)) == 0, 1).otherwise(F.col("hd.KURSK"))
           )).alias("GrossSOPriceUSD"),
           
    # HighDollarFlag (Defined at top of SQL)
    F.when(
        (F.col("a.NETWR") * F.when(F.col("a.WAERK").isin('JPY', 'TWD'), 
                F.when(F.coalesce(F.col("hd.KURSK"), F.lit(0)) == 0, 1).otherwise(F.col("hd.KURSK")) * 100
               ).otherwise(
                F.when(F.coalesce(F.col("hd.KURSK"), F.lit(0)) == 0, 1).otherwise(F.col("hd.KURSK"))
               )) > 50000, 
        "True"
    ).otherwise("False").alias("HighDollarFlag"),

    F.when(F.current_date() >= F.col("e.EDATU"), "True").otherwise("False").alias("DeliveryDueFlag"),
    F.col("p.POSEX").alias("CustomerPoLine"),
    F.lit(None).alias("Cancellation"),
    F.lit(None).alias("CancellationIndicatorFlag"),
    F.col("xy.CARRIER").alias("Carrier"),
    F.col("xy.CARRIER_NAME").alias("CarrierName"),
    F.col("d.ZTERM").alias("CreditCheckBlock"),
    F.when(F.coalesce(F.col("p.ABGRU"), F.lit("")) != "", "True").otherwise("False").alias("SOLineRejectionFlag"),
    F.col("ActivityType")
)

# Write to Delta Table
df_result.write.format("delta").mode("overwrite").saveAsTable(params["target"])
