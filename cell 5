# #### Step-11 -- Final Insert (Faithful Logic)

base = (
    nhalist.alias("a")
    # Left Joins are now safe because mfg_all is unique (deduplicated in Step 5)
    .join(mfg_all.alias("b"), nhalist.nha == mfg_all.nha_cd, "left")
    .join(demand_all.alias("c"), nhalist.nha == demand_all.nha_cd, "left")
    .join(sprs_all.alias("d"), nhalist.nha == sprs_all.nha_cd, "left")
    .join(lamqoh.alias("g"), nhalist.nha == lamqoh.nha_cd, "left")
    .join(openpo.alias("h"), nhalist.nha == openpo.nha_cd, "left")
    .select(
        nhalist.cmpprtno.alias("cmpprtno"),
        nhalist.nha.alias("nha"),
        F.col("b.mfg_3yrs_consumption").cast("int"),
        F.col("b.mfg_12mnths_consumption").cast("int"),
        F.col("b.mfg_5yrs_consumption").cast("int"),
        F.col("c.mfg_dmd").cast("int"),
        F.col("c.sprs_dmd").cast("int"),
        F.col("d.sprs_3yrs_consumption").cast("int"),
        F.col("d.sprs_5yrs_consumption").cast("int"),
        F.col("g.lamqoh").cast("int"),
        F.col("g.restricted_all_stock").cast("int"),
        F.col("h.open_po_qty").cast("int")
    )
)


# --- DEFINING THE INCLUSION LOGIC EXPLICITLY ---

# Condition 1: CMPPRTNO equals NHA (The "Self-Reference" Branch)
cond_self = (F.col("cmpprtno") == F.col("nha"))

# Condition 2: Any Metric is Greater Than Zero (The "Activity" Branch)
cond_activity = (
    (F.coalesce(F.col("mfg_3yrs_consumption"), F.lit(0)) > 0) |
    (F.coalesce(F.col("mfg_dmd"), F.lit(0)) > 0) |
    (F.coalesce(F.col("sprs_dmd"), F.lit(0)) > 0) |
    (F.coalesce(F.col("sprs_3yrs_consumption"), F.lit(0)) > 0) |
    (F.coalesce(F.col("mfg_12mnths_consumption"), F.lit(0)) > 0) |
    (F.coalesce(F.col("open_po_qty"), F.lit(0)) > 0) |
    (F.coalesce(F.col("mfg_5yrs_consumption"), F.lit(0)) > 0) |
    (F.coalesce(F.col("sprs_5yrs_consumption"), F.lit(0)) > 0)
)

# Faithful Replication of SAP UNION DISTINCT:
# (Rows from Branch 1) OR (Rows from Branch 2)
final = (
    base
    .filter(cond_self | cond_activity)   # <- UNION DISTINCT equivalent
    .distinct()
    .withColumn("last_modified_on", F.current_date())
)


final.createOrReplaceTempView("final_dmd")

spark.sql(f"""
INSERT INTO {tgt_dmd} 
(cmpprtno, nha, mfg_3yrs_consumption, mfg_dmd, sprs_dmd, sprs_3yrs_consumption,
 mfg_12mnths_consumption, lamqoh, restricted_all_stock, open_po_qty, 
 last_modified_on, mfg_5yrs_consumption, sprs_5yrs_consumption)
SELECT 
 cmpprtno, nha, mfg_3yrs_consumption, mfg_dmd, sprs_dmd, sprs_3yrs_consumption,
 mfg_12mnths_consumption, lamqoh, restricted_all_stock, open_po_qty, 
 last_modified_on, mfg_5yrs_consumption, sprs_5yrs_consumption
FROM final_dmd
""")









Mostly yes, but not 100% guaranteed faithful — your Step‑11 logic is now correct, however you still differ from SAP in at least (1) the MKPF↔MSEG join key (mblnr+mjahr vs SAP mblnr only) and (2) the way MAKT/language grain is handled/deduped, which can change results in edge cases..py)
