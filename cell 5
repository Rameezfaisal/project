computed cmpqpa (Component Quantity Per Assembly) for every NHA.
In SAP:
CMPQPA = how many units of the component exist inside each higher-level NHA.
Logic:
Level 1 → cmpqpa = bomqpa
Level 2+ →
Copy code

cmpqpa = bomqpa × sum(parent cmpqpa)
This propagates the quantity up the BOM hierarchy, exactly like SAP’s nested WHILE loops.
Now every NHA row in nhalist has the correct rolled-up quantity.








# Prepare final NHA rows
df_final_nha = (
    df_nhalist
    .filter(~F.col("nhamstae").isin("ob","os","op"))
    .select(
        F.col("cmpprtno").alias("cmpprtno"),
        F.col("nha").alias("nha"),
        F.col("level").alias("level"),
        F.col("childpn").alias("childpn"),
        F.col("bomitem").alias("bomitem"),
        F.col("bomqpa").alias("bomqpa"),
        F.col("cmpqpa").alias("cmpqpa"),
        F.col("nhamatkl").alias("matkl"),
        F.col("nhamstae").alias("mstae"),
        F.col("exploded").alias("exploded"),
        F.current_date().alias("last_modified_on"),
        F.lit("A").alias("nha_status_inactive")
    )
)

df_final_nha.createOrReplaceTempView("df_final_nha")

# Explicit-column INSERT (Delta-safe)
spark.sql(f"""
INSERT INTO {tgt_nha_dtls}
(
    cmpprtno,
    nha,
    level,
    childpn,
    bomitem,
    bomqpa,
    cmpqpa,
    matkl,
    mstae,
    exploded,
    last_modified_on,
    nha_status_inactive
)
SELECT
    cmpprtno,
    nha,
    level,
    childpn,
    bomitem,
    bomqpa,
    cmpqpa,
    matkl,
    mstae,
    exploded,
    last_modified_on,
    nha_status_inactive
FROM df_final_nha
""")