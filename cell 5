Cell 5: Main Join & Filtering Logic
​Business Context:
This is the core "engine" of the procedure. It reconstructs the complex relationships between 25 tables.
​Strict Join Types: It respects the SAP logic where foundational tables (Order Header/Item, Schedule Lines, Status) are Inner Joins (must exist), while enrichment tables (Delivery Logs, Lab Office, Production info) are Left Joins (optional).
​Complex MARD Join: It implements the specific "Storage Location Substitution" rule (e.g., swapping loc '0010' for '0030' in Plant 3000) directly in the join condition.
​Global Filters: It applies the "Open Order" logic vs. "Historical Data" logic (732 days lookback) to ensure the table captures active business + relevant history.










# CELL 5: Main Join Logic
# Reconstructing the FROM clause with strict Inner vs Left join adherence

df_main = df_vbep_calc.alias("e") \
    .join(df_vbap, (F.col("e.vbeln") == F.col("p.vbeln")) & (F.col("e.posnr") == F.col("p.posnr")), "inner") \
    .join(df_vbak, F.col("a.vbeln") == F.col("p.vbeln"), "inner") \
    .join(df_vbuk, F.col("u.vbeln") == F.col("p.vbeln"), "inner") \
    .join(df_vbup, (F.col("b.vbeln") == F.col("p.vbeln")) & (F.col("b.posnr") == F.col("p.posnr")), "inner") \
    .join(df_kna1, F.col("a.kunnr") == F.col("k.kunnr"), "inner") \
    .join(df_part, F.col("p.matnr") == F.col("pp.part"), "inner") \
    .join(df_mara, F.col("p.matnr") == F.col("m.matnr"), "inner") \
    .join(df_h, (F.col("p.vbeln") == F.col("h_vbeln")) & (F.col("p.posnr") == F.col("h_posnr")), "inner") \
    .join(df_c, F.col("a.vbeln") == F.col("c_vbeln"), "inner") \
    .join(df_f1, (F.col("b.vbeln") == F.col("f1_vbeln")) & (F.col("b.posnr") == F.col("f1_posnr")), "left") \
    .join(df_f2, (F.col("b.vbeln") == F.col("f2_vbeln")) & (F.col("b.posnr") == F.col("f2_posnr")), "left") \
    .join(df_lab, F.col("m.labor") == F.col("i_labor"), "left") \
    .join(df_l, (F.col("p.vbeln") == F.col("l_vbeln")) & (F.col("p.posnr") == F.col("l_posnr")), "left") \
    .join(df_mbew, (F.col("p.matnr") == F.col("w.matnr")) & (F.col("w.bwkey") == '2000'), "left") \
    .join(df_hd, F.col("p.vbeln") == F.col("hd_vbeln"), "left") \
    .join(df_d, (F.col("p.vbeln") == F.col("d_vbeln")) & (F.col("p.posnr") == F.col("d_posnr")), "left") \
    .join(df_j, F.col("a.objnr") == F.col("j_objnr"), "left") \
    .join(df_vekp, F.col("f1_vbeln") == F.col("vekp.vpobjkey"), "left") \
    .join(df_qmel, F.col("a.vbeln") == F.col("q.aufnr"), "left") \
    .join(df_xy, (F.col("p.vbeln") == F.col("xy_vbeln")) & (F.col("p.posnr") == F.col("xy_posnr")), "left") \
    .join(df_afko, F.col("a.aufnr") == F.col("afko.aufnr"), "left") \
    .join(df_act, F.col("afko.aufpl") == F.col("act_aufpl"), "left") \
    .join(df_curr_calc, F.col("a.waerk") == F.col("x_fcurr"), "left") \
    .join(df_marc, (F.col("p.werks") == F.col("z.werks")) & (F.col("p.matnr") == F.col("z.matnr")), "left") \
    .join(df_mard, 
          (F.col("p.werks") == F.col("r.werks")) & 
          (F.col("p.matnr") == F.col("r.matnr")) &
          (
             # Storage Location Substitution Logic from SAP Script
             F.when((F.coalesce(F.col("p.lgort"), F.lit('')) == '') & (F.col("p.werks") == '3000'), '0030')
              .when(F.coalesce(F.col("p.lgort"), F.lit('')) != '', F.col("p.lgort"))
              .otherwise('0010') == F.col("r.lgort")
          ), 
          "left")

# --- Filtering Logic ---

# 1. Define "Open Order" complex logic 
# Checks: Status not Complete, Not Rejected, Has Open Qty, Backorder exists
condition_open_order = (
    (F.coalesce(F.col("u.wbstk"), F.lit('')) != 'C') & 
    (F.coalesce(F.col("u.lfgsk"), F.lit('')) != 'C') &
    (F.coalesce(F.col("p.abgru"), F.lit('')) == '') &
    (~F.col("b.lfsta").isin('', ' ')) &
    (F.coalesce(F.col("p.kwmeng"), F.lit(0)) > F.coalesce(F.col("delvd_qty"), F.lit(0))) &
    (F.coalesce(F.col("e.bmeng"), F.lit(0)) > 0) &
    (
        F.when(F.coalesce(F.col("ExpectedQtyCumulative"), F.lit(0)) <= F.coalesce(F.col("delvd_qty"), F.lit(0)), 0)
         .when((F.coalesce(F.col("ExpectedQtyCumulative"), F.lit(0)) - F.coalesce(F.col("delvd_qty"), F.lit(0))) <= F.coalesce(F.col("e.bmeng"), F.lit(0)),
               F.coalesce(F.col("ExpectedQtyCumulative"), F.lit(0)) - F.coalesce(F.col("delvd_qty"), F.lit(0)))
         .otherwise(F.coalesce(F.col("e.bmeng"), F.lit(0))) > 0
    )
)

# 2. Apply Main Filter (Active Records OR Recent History)
df_filtered = df_main.filter(
    (F.col("p.werks") >= '1900') & 
    (~F.col("a.auart").isin('ZVC', 'ZR07')) & 
    (
        (F.col("p.erdat") >= F.date_add(F.current_date(), -732)) | 
        condition_open_order
    )
)



