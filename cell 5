# CELL 6: Business Logic & Filtering (Replica of CV_SQL_SO)

# --- 1. Define Logic for Quantities ---
expr_pgi_qty = (
    F.when(F.coalesce(F.col("prst.f1_delvd_qty"), F.lit(0)) >= F.coalesce(F.col("prst.e_ExpectedQtyCumulative"), F.lit(0)), 
           F.coalesce(F.col("prst.bmeng"), F.lit(0)))
     .when(F.coalesce(F.col("prst.f1_delvd_qty"), F.lit(0)) < F.coalesce(F.col("prst.e_ExpectedQtyCumulative"), F.lit(0)), 
           F.greatest(
               F.coalesce(F.col("prst.bmeng"), F.lit(0)) - (F.coalesce(F.col("prst.e_ExpectedQtyCumulative"), F.lit(0)) - F.coalesce(F.col("prst.f1_delvd_qty"), F.lit(0))), 
               F.lit(0)
           ))
     .otherwise(0)
)

expr_open_qty_val = (
     F.when(F.coalesce(F.col("prst.e_ExpectedQtyCumulative"), F.lit(0)) <= F.coalesce(F.col("prst.f1_delvd_qty"), F.lit(0)), 0)
      .when((F.coalesce(F.col("prst.e_ExpectedQtyCumulative"), F.lit(0)) - F.coalesce(F.col("prst.f1_delvd_qty"), F.lit(0))) <= F.coalesce(F.col("prst.bmeng"), F.lit(0)),
            F.coalesce(F.col("prst.e_ExpectedQtyCumulative"), F.lit(0)) - F.coalesce(F.col("prst.f1_delvd_qty"), F.lit(0)))
      .otherwise(F.coalesce(F.col("prst.bmeng"), F.lit(0)))
)

# --- 2. Define Filter Condition (Using Renamed p_erdat) ---
# FIX: Use "prst.p_erdat" (Item Date) for history check, as per SAP script logic logic
cond_history = (F.col("prst.p_erdat") >= F.date_add(F.current_date(), -732))

cond_is_open = (
    (F.coalesce(F.col("prst.wbstk"), F.lit('')) != 'C') &
    (F.coalesce(F.col("prst.abgru"), F.lit('')) == '') &
    (F.coalesce(F.col("prst.lfsta"), F.lit('')) != '') &
    (expr_open_qty_val > 0)
)

# Apply Filter
df_filtered = df_joined.filter(
    (F.col("prst.werks") >= '1900') & 
    (~F.col("prst.auart").isin('ZVC', 'ZR07')) & 
    (cond_history | cond_is_open)
)

# --- 3. Define Business Columns ---
col_OrderGroup = (
    F.when(F.col("prst.auart").isin('ZAS','ZAV','ZFD','ZO11','ZSA','ZSB','ZSR','RK','ZCR1','ZDR1'), 'OTH')
     .when(F.col("prst.auart").isin('AG','ZQ01','ZQ03','ZQ04','ZQFO','ZQIS','ZQUP','ZQUX','ZUQT'), 'QT')
     .when(F.col("prst.auart").isin('ZO03','ZRA1','ZSO1'), 'RPO')
     .when(F.col("prst.auart").isin('ZR11','ZR03','ZR04','ZR05','ZR08','ZR4B','ZUPC','ZUPR','ZFOC'), 'RTN')
     .when(F.col("prst.auart").isin('ZO09','ZO12','ZSD','TA','ZCON','ZFO','ZSO','ZUP','ZUPX','ZO04'), 'SO')
     .otherwise('SO')
)

col_BillingBlk = (
    F.when(F.coalesce(F.col("prst.faksk"), F.lit('')) != '', F.concat(F.lit("BLK(H) "), F.col("prst.faksk")))
     .when(F.coalesce(F.col("prst.faksp"), F.lit('')) != '', F.concat(F.lit("BLK(L) "), F.col("prst.faksp")))
     .otherwise('')
)

col_VendorSloc = (
    F.when((F.coalesce(F.col("prst.lgort"), F.lit('')) == '') & (F.col("prst.werks") == '3000'), '0030')
     .when(F.coalesce(F.col("prst.lgort"), F.lit('')) != '', F.col("prst.lgort"))
     .otherwise('0010')
)

col_Region = (
    F.when(F.col("prst.vkorg") == '9000', 'NA')
     .when(F.col("prst.vkorg").between('2000', '2900'), 'EU')
     .when(F.col("prst.vkorg").between('3000', '3001'), 'JP')
     .when(F.col("prst.vkorg") == '3100', 'TW')
     .when(F.col("prst.vkorg") == '3200', 'KR')
     .when(F.col("prst.vkorg").isin('3300', '3600'), 'SEA')
     .when(F.col("prst.vkorg").isin('3400', '3410', '1000'), 'CN')
     .otherwise('NEW')
)

col_ToolType = (
    F.when(F.col("m.labor") == '023', 'SPIN')
     .when(F.col("m.labor") == '024', 'DEP')
     .otherwise('ETCH+')
)

rate_calc = F.when((F.coalesce(F.col("hd_inco.hd_kursk"), F.lit(0)) == 0) | (F.col("prst.waerk") == 'USD'), 1).otherwise(F.col("hd_inco.hd_kursk"))

col_UnitPriceUSD = (
    (F.when(F.col("prst.waerk").isin('JPY','TWD'), F.col("prst.netpr") * 100).otherwise(F.col("prst.netpr"))) * rate_calc
)

col_GrossSOPriceUSD = (
    F.col("prst.netwr") * F.when(F.col("prst.waerk").isin('JPY','TWD'), rate_calc * 100).otherwise(rate_calc)
)

# Apply Logic
df_final_logic = df_filtered.select(
    "*", 
    col_OrderGroup.alias("calc_OrderGroup"),
    col_BillingBlk.alias("calc_BillingBlk"),
    col_VendorSloc.alias("calc_VendorSloc"),
    col_Region.alias("calc_Region"),
    col_ToolType.alias("calc_ToolType"),
    col_UnitPriceUSD.alias("calc_UnitPriceUSD"),
    col_GrossSOPriceUSD.alias("calc_GrossSOPriceUSD"),
    expr_pgi_qty.alias("calc_PGIQty"),
    F.when(cond_is_open, expr_open_qty_val).otherwise(0).alias("calc_OpenQty"),
    F.when(cond_is_open, 'Open').otherwise('Closed').alias("calc_OrderStatus")
)

print("Cell 6 Complete: Business Logic applied with fixed Dates.")








AnalysisException                         Traceback (most recent call last)
Cell In[82], line 34
     26 cond_is_open = (
     27     (F.coalesce(F.col("prst.wbstk"), F.lit('')) != 'C') &
     28     (F.coalesce(F.col("prst.abgru"), F.lit('')) == '') &
     29     (F.coalesce(F.col("prst.lfsta"), F.lit('')) != '') &
     30     (expr_open_qty_val > 0)
     31 )
     33 # Apply Filter
---> 34 df_filtered = df_joined.filter(
     35     (F.col("prst.werks") >= '1900') & 
     36     (~F.col("prst.auart").isin('ZVC', 'ZR07')) & 
     37     (cond_history | cond_is_open)
     38 )
     40 # --- 3. Define Business Columns ---
     41 col_OrderGroup = (
     42     F.when(F.col("prst.auart").isin('ZAS','ZAV','ZFD','ZO11','ZSA','ZSB','ZSR','RK','ZCR1','ZDR1'), 'OTH')
     43      .when(F.col("prst.auart").isin('AG','ZQ01','ZQ03','ZQ04','ZQFO','ZQIS','ZQUP','ZQUX','ZUQT'), 'QT')
   (...)
     47      .otherwise('SO')
     48 )

File /opt/spark/python/lib/pyspark.zip/pyspark/sql/dataframe.py:3331, in DataFrame.filter(self, condition)
   3329     jdf = self._jdf.filter(condition)
   3330 elif isinstance(condition, Column):
-> 3331     jdf = self._jdf.filter(condition._jc)
   3332 else:
   3333     raise PySparkTypeError(
   3334         error_class="NOT_COLUMN_OR_STR",
   3335         message_parameters={"arg_name": "condition", "arg_type": type(condition).__name__},
   3336     )

File ~/cluster-env/trident_env/lib/python3.11/site-packages/py4j/java_gateway.py:1322, in JavaMember.__call__(self, *args)
   1316 command = proto.CALL_COMMAND_NAME +\
   1317     self.command_header +\
   1318     args_command +\
   1319     proto.END_COMMAND_PART
   1321 answer = self.gateway_client.send_command(command)
-> 1322 return_value = get_return_value(
   1323     answer, self.gateway_client, self.target_id, self.name)
   1325 for temp_arg in temp_args:
   1326     if hasattr(temp_arg, "_detach"):

File /opt/spark/python/lib/pyspark.zip/pyspark/errors/exceptions/captured.py:185, in capture_sql_exception.<locals>.deco(*a, **kw)
    181 converted = convert_exception(e.java_exception)
    182 if not isinstance(converted, UnknownException):
    183     # Hide where the exception came from that shows a non-Pythonic
    184     # JVM exception message.
--> 185     raise converted from None
    186 else:
    187     raise

AnalysisException: [AMBIGUOUS_REFERENCE] Reference `prst`.`lfsta` is ambiguous, could be: [`prst`.`lfsta`, `prst`.`lfsta`].
