Cell 7 performed the multi-level BOM explosion, which is the heart of the SAP procedure.
In SAP:
For every part in the current level that is not obsolete and not yet exploded,
find its parent assemblies from BOMREC and add them as the next level NHAs.
What we now have in nhalist:
Copy code

CMP Part
   ↓
Level 1 → itself
Level 2 → its immediate parents (NHAs)
Level 3 → parents of those NHAs
...
up to 15 levels
Every row tracks:
which OB part (cmpprtno)
which NHA
which child it came from
BOM quantity
material status & type
whether it has already been exploded
This is a graph traversal of the BOM, implemented in Spark.









# Assign row numbers per level (SAP ROWN0)
w = Window.partitionBy("level").orderBy("nha", "childpn")

df_nhalist = df_nhalist.withColumn("rowno", F.row_number().over(w))

# Level 1 CMPQPA = BOMQPA
df_nhalist = df_nhalist.withColumn(
    "cmpqpa",
    F.when(F.col("level") == 1, F.col("bomqpa")).otherwise(F.col("cmpqpa"))
)

# Find max level
max_level = df_nhalist.select(F.max("level")).collect()[0][0]

# Propagate CMPQPA up the BOM
for lvl in range(2, max_level + 1):

    parent = (
        df_nhalist
        .filter(F.col("level") == lvl - 1)
        .select(
            F.col("nha").alias("parent_nha"),
            F.col("cmpqpa").alias("parent_cmpqpa")
        )
    )

    df_nhalist = (
        df_nhalist.alias("x")
        .join(
            parent.alias("y"),
            (F.col("x.childpn") == F.col("y.parent_nha")) &
            (F.col("x.level") == lvl),
            "left"
        )
        .withColumn(
            "cmpqpa",
            F.when(
                F.col("x.level") == lvl,
                F.col("x.bomqpa") * F.coalesce(F.col("y.parent_cmpqpa"), F.lit(0))
            ).otherwise(F.col("x.cmpqpa"))
        )
        .select("x.*")
    )

# Refresh temp view
df_nhalist.createOrReplaceTempView("nhalist")
